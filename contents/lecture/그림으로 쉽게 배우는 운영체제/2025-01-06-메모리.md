---
title: 메모리
categories: [그림으로 쉽게 배우는 운영체제]
date: 2025-01-06 01:00:00 +0900
tags: [CS]
---

# 절대 주소, 상대 주소
- 메모리에는 운영체제가 실행되고 있는 공간이 존재
- 다른 프로세스가 운영체제의 메모리 공간에 접근하면 안됨
- 개발자와 CPU는 0x0 부터 코드가 메모리를 사용하도록 코딩 및 실행 => 상대(논리)주소
- 메모리 관리자는 이 상대 주소를 실제 물리적인 주소로 변환하여 메모리를 관리 => 절대(물리)주소

# 가변 분할 방식(세그멘테이션)
- 프로세스에 메모리를 동적으로 할당
- 프로세스에 필요한 만큼 메모리를 연속적으로 할당
- 외부 단편화 : 메모리 크기가 충분하지만 연속되지 않아 사용하지 못하는 부분 발생 => 1MB, 1MB의 빈공간이 있을때 2MB의 프로세스를 할당할 수 없음 => 떨어져 있는 이 두 부분을 합치는 과정에서 오버헤드드

# 고정 분할 방식(페이징)
- 메모리를 여러 개의 고정된 크기로 나누어 사용
- 나누어진 조각 1개 이상을 프로세스에게 할당, 불연속일 수 있음
- 내부 단편화 : 나누어진 조각에 프로세스를 할당하고 남는 부분이 발생

# 버디 시스템
- 실제 사용하는 메로리 시스템으로 고정, 가변 분할 방식을 혼합
- 요청받은 프로세스를 할당할 수 있으면서도 2의 제곱수 중 가장 작도록 분할하여 할당(32KB 프로세스 요청 예시시)
![image](https://github.com/user-attachments/assets/0bde372e-1e52-4bdc-9c5d-b66711c8a2b4)
- 프로세스 종료 이후 다시 합침
- 내부 단편화 : 가능한 작게 나누어 할당하므로 내부 단편화가 적음
- 외부 단편화 : 떨어져 있는 부분을 합치는게 쉬움(2의 제곱수로 나누어져 있으므로)

# 가상 메모리
- HDD의 스왑영역을 메모리처럼 사용
- 메모리 관리자는 HDD의 스왑영역과 실제 메모리를 합쳐서 관리
- 프로세스의 논리 주소는 메모리 관리자를 거쳐 실제 메모리 주소로 변환하며 프로세스는 논리 주소의 위치가 HDD의 스왑영역인지 실제 메모리인지 모름