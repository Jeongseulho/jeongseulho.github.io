{"componentChunkName":"component---src-templates-post-template-tsx","path":"/tech/2023-07-31-Token을-어떻게-관리할-것인가/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2 id=\"0-들어가며\" style=\"position:relative;\"><a href=\"#0-%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"0 들어가며 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0. 들어가며</h2>\n<p>진행하는 프로젝트의 요구사항에서 Access Token과 Refresh Token을 사용하여 인증, 인가를 구현해야하는 상황이었다. 프론트에서 이러한 토큰을 어떻게 관리해야하는지 고민한 내용을 정리해보았다.</p>\n<h2 id=\"1-token을-어떻게-관리할-것인가\" style=\"position:relative;\"><a href=\"#1-token%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%A0-%EA%B2%83%EC%9D%B8%EA%B0%80\" aria-label=\"1 token을 어떻게 관리할 것인가 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1 Token을 어떻게 관리할 것인가</h2>\n<p><code class=\"language-text\">Token</code>을 필요시에 서버로 보내야한다, 그러면 어디에 저장해 두어야할까? 각 토큰의 요구사항을 기반으로 관리 방법을 정해보았다.</p>\n<h3 id=\"1-access-token의-요구사항\" style=\"position:relative;\"><a href=\"#1-access-token%EC%9D%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD\" aria-label=\"1 access token의 요구사항 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(1) Access Token의 요구사항</h3>\n<p><strong><code class=\"language-text\">Access Token</code>에 관한 요구사항은 무엇일까?</strong></p>\n<ul>\n<li>로그인 여부의 기준이 되어야한다.</li>\n<li>로그인이 되어있는지에 따라 동적으로 달라지는 UI가 존재하므로 변화를 감지할 수 있어야한다.</li>\n<li>인가에 필요한 중요한 정보이므로, 보안에 취약하지 않은 곳에 저장해야한다.</li>\n</ul>\n<h3 id=\"2-refresh-token의-요구사항\" style=\"position:relative;\"><a href=\"#2-refresh-token%EC%9D%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD\" aria-label=\"2 refresh token의 요구사항 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(2) Refresh Token의 요구사항</h3>\n<p><strong><code class=\"language-text\">Refresh Token</code>에 관한 요구사항은 무엇일까?</strong></p>\n<ul>\n<li><code class=\"language-text\">Access Token</code>이 만료되거나 존재하지 않을 시, 새로운 <code class=\"language-text\">Access Token</code>을 발급받기 위해 서버에 보낼 수 있어야한다.</li>\n<li>이 또한 <code class=\"language-text\">Access Token</code> 발급에 필요한 중요한 정보이므로, 보안에 취약하지 않은 곳에 저장해야한다.</li>\n</ul>\n<h3 id=\"3-관리-방법-결정\" style=\"position:relative;\"><a href=\"#3-%EA%B4%80%EB%A6%AC-%EB%B0%A9%EB%B2%95-%EA%B2%B0%EC%A0%95\" aria-label=\"3 관리 방법 결정 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(3) 관리 방법 결정</h3>\n<p><strong><code class=\"language-text\">Access Token</code>는 어디에서 관리할까?</strong><br>\n<code class=\"language-text\">Access Token</code>를 <code class=\"language-text\">local &amp; session storage</code>로 관리하면, <code class=\"language-text\">storage event</code>를 사용하여 UI를 동적으로 변경할 수 있다. 당연히 상태로 관리하여도 가능하다.<br>\n반면에 <code class=\"language-text\">cookie</code>는 <code class=\"language-text\">httpOnly</code> 옵션을 사용할 경우 감지할 수 없다. 프론트에서 <code class=\"language-text\">cookie</code>를 갖고 있는지 매번 서버에 요청을 보내 확인해야하는 번거로운 작업이 필요하다.<br>\n나는 상태로 관리하는 것이 보안 측면에서도 동적으로 UI를 변경할 수 있는 측면에서도 더 좋다고 판단했다.\r\n<a href=\"https://jeongseulho.github.io/posts/XSS%EC%99%80-CSRF/\" target=\"_blank\" rel=\"nofollow\">storage와 cookie는 왜 위험한가</a></p>\n<p><strong><code class=\"language-text\">Refresh Token</code>는 어디에서 관리할까?</strong><br>\n<code class=\"language-text\">Refresh Token</code>를 상태에 저장할 경우 새로고침시 <code class=\"language-text\">Access Token</code>과 같이 초기화 되기 때문에 로그인을 유지할 방법이 없다, 그러면 <code class=\"language-text\">storage</code> 혹은 <code class=\"language-text\">cookie</code>인데 <code class=\"language-text\">cookie</code>는 여러 보안옵션을 제공하여 <code class=\"language-text\">storage</code>보다 안전하면서도 서버 요청에 자동으로 쿠키가 전송되도록 설정할 수 있어 편리하다고 판단했다.</p>\n<p>최종적으로 <code class=\"language-text\">Access Token</code>은 전역 상태로 관리하고, <code class=\"language-text\">Refresh Token</code>은 <code class=\"language-text\">cookie</code>로 관리하기로 결정했다.</p>\n<h2 id=\"2-새로고침시-로그인이-풀려버리는-문제\" style=\"position:relative;\"><a href=\"#2-%EC%83%88%EB%A1%9C%EA%B3%A0%EC%B9%A8%EC%8B%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%B4-%ED%92%80%EB%A0%A4%EB%B2%84%EB%A6%AC%EB%8A%94-%EB%AC%B8%EC%A0%9C\" aria-label=\"2 새로고침시 로그인이 풀려버리는 문제 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2 새로고침시 로그인이 풀려버리는 문제</h2>\n<p>단, <code class=\"language-text\">Access Token</code>을 전역 상태로 관리하면 새로고침시 <code class=\"language-text\">Access Token</code>이 사라지기 때문에 로그인이 풀려버리는 문제를 해결해야 한다.<br>\n이를 해결하기 위해 <code class=\"language-text\">useEffect</code>를 사용해 첫 렌더링시에 <code class=\"language-text\">Refresh Token</code> 보유 여부와 상관없이 재발급 요청을 보내고 만약 <code class=\"language-text\">Refresh Token</code>를 보유하고 있는 경우에만 <code class=\"language-text\">Access Token</code>을 발급받는 로직을 구현했다.</p>\n<blockquote>\n<p>Refresh Token은 cookie의 httpOnly 옵션으로 인해 보유 여부를 확인할 수 없기 때문에</p>\n</blockquote>\n<h2 id=\"3-분명히-쿠키는-저장되어있는데-왜-api-요청에-쿠키가-전송되지-않을까\" style=\"position:relative;\"><a href=\"#3-%EB%B6%84%EB%AA%85%ED%9E%88-%EC%BF%A0%ED%82%A4%EB%8A%94-%EC%A0%80%EC%9E%A5%EB%90%98%EC%96%B4%EC%9E%88%EB%8A%94%EB%8D%B0-%EC%99%9C-api-%EC%9A%94%EC%B2%AD%EC%97%90-%EC%BF%A0%ED%82%A4%EA%B0%80-%EC%A0%84%EC%86%A1%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84%EA%B9%8C\" aria-label=\"3 분명히 쿠키는 저장되어있는데 왜 api 요청에 쿠키가 전송되지 않을까 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3 분명히 쿠키는 저장되어있는데 왜 API 요청에 쿠키가 전송되지 않을까?</h2>\n<p>다 구현하고 테스트를 하려는데 아무리해도 서버로 쿠키가 전송되지 않는 문제가 발생했다.<br>\n원인은 크롬에서 <code class=\"language-text\">same site</code>옵션이 <code class=\"language-text\">None</code>인 경우 필수로 <code class=\"language-text\">secure</code> 옵션이 필요하다는 것이었다. 나는 로컬 환경에서 배포된 서버로 요청을 보내어 <code class=\"language-text\">same site</code>가 <code class=\"language-text\">None</code>이었으며 배포된 서버는 아직 <code class=\"language-text\">https</code>가 적용되지 않았기 때문에 쿠키가 전송되지 않았던 것이다.<br>\n<a href=\"https://developers.google.com/search/blog/2020/01/get-ready-for-new-samesitenone-secure?hl=ko\" target=\"_blank\" rel=\"nofollow\">크롬의 쿠키 설정 업데이트</a></p>\n<h2 id=\"4-마치며\" style=\"position:relative;\"><a href=\"#4-%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"4 마치며 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4 마치며</h2>\n<p>최종 구현한 방법은</p>\n<ol>\n<li><code class=\"language-text\">Access Token</code>은 전역 상태로 관리한다.</li>\n<li><code class=\"language-text\">Refresh Token</code>은 <code class=\"language-text\">cookie</code>로 관리한다.(단, 보안을 위해 <code class=\"language-text\">same site</code>, <code class=\"language-text\">secure</code>, <code class=\"language-text\">httpOnly</code> 옵션을 사용하고 백엔드에서 수명을 조절)</li>\n<li>새로고침에서 로그인이 풀리는 문제를 해결하기 위해 첫 렌더링시에 <code class=\"language-text\">Refresh Token</code> 보유 여부와 상관없이 재발급 요청을 보내고 <code class=\"language-text\">Refresh Token</code>를 보유하고 있는 경우에만 <code class=\"language-text\">Access Token</code>을 발급받는 로직을 구현한다.</li>\n</ol>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#0-%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\">0. 들어가며</a></p>\n</li>\n<li>\n<p><a href=\"#1-token%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%A0-%EA%B2%83%EC%9D%B8%EA%B0%80\">1 Token을 어떻게 관리할 것인가</a></p>\n<ul>\n<li><a href=\"#1-access-token%EC%9D%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD\">(1) Access Token의 요구사항</a></li>\n<li><a href=\"#2-refresh-token%EC%9D%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD\">(2) Refresh Token의 요구사항</a></li>\n<li><a href=\"#3-%EA%B4%80%EB%A6%AC-%EB%B0%A9%EB%B2%95-%EA%B2%B0%EC%A0%95\">(3) 관리 방법 결정</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-%EC%83%88%EB%A1%9C%EA%B3%A0%EC%B9%A8%EC%8B%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%B4-%ED%92%80%EB%A0%A4%EB%B2%84%EB%A6%AC%EB%8A%94-%EB%AC%B8%EC%A0%9C\">2 새로고침시 로그인이 풀려버리는 문제</a></p>\n</li>\n<li>\n<p><a href=\"#3-%EB%B6%84%EB%AA%85%ED%9E%88-%EC%BF%A0%ED%82%A4%EB%8A%94-%EC%A0%80%EC%9E%A5%EB%90%98%EC%96%B4%EC%9E%88%EB%8A%94%EB%8D%B0-%EC%99%9C-api-%EC%9A%94%EC%B2%AD%EC%97%90-%EC%BF%A0%ED%82%A4%EA%B0%80-%EC%A0%84%EC%86%A1%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84%EA%B9%8C\">3 분명히 쿠키는 저장되어있는데 왜 API 요청에 쿠키가 전송되지 않을까?</a></p>\n</li>\n<li>\n<p><a href=\"#4-%EB%A7%88%EC%B9%98%EB%A9%B0\">4 마치며</a></p>\n</li>\n</ul>","frontmatter":{"title":"Token을 어떻게 관리할 것인가","summary":"프론트에서 토큰을 어떻게 관리해야하는지 고민한 내용을 정리","date":"2023년 07월 31일","tags":["JWT","보안"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVR42mNggAFGRkYQCUakAUZGJgYGBiEhIR4eHrARpJjAzMSkFRs+afXKmRl5Lhy8DAwMTCCnMEKcw8zMzMnJycDAwMrKKiAgwMvLC7OTCWSnmJmT26oNxWsWb3JJmqrQrMJjyMDAoCCvaGRkZGJiYmNjk5CQYAgGOTk5gYGBUG9CHGxjkNCQdUOIT0JLw7Om6LaCvCkDA4Ourp6Li4uPj09ERERQUFBycrKysrK1tbWGhgbIaUxMDCDIwGAq4L5auWxzWknhiX3WE2byyqiANOvpqaiomJiYREREqKmppaenc3Bw6OjoSEtLwwMY7GcWZj8u/vntXWVTJ8k42YG9w8gE9hETExMLCwvEw/hCm4eHh4ODA85lxAaw62cCRw8+FRgAAAx4MPGru1YVAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/60615dd0a50be3f0619f28c8c9b06c4c/e1dc3/image.png","srcSet":"/static/60615dd0a50be3f0619f28c8c9b06c4c/e51b2/image.png 193w,\n/static/60615dd0a50be3f0619f28c8c9b06c4c/bb017/image.png 386w,\n/static/60615dd0a50be3f0619f28c8c9b06c4c/e1dc3/image.png 772w","sizes":"(min-width: 772px) 772px, 100vw"},"sources":[{"srcSet":"/static/60615dd0a50be3f0619f28c8c9b06c4c/c87e4/image.webp 193w,\n/static/60615dd0a50be3f0619f28c8c9b06c4c/4cd58/image.webp 386w,\n/static/60615dd0a50be3f0619f28c8c9b06c4c/d0ce5/image.webp 772w","type":"image/webp","sizes":"(min-width: 772px) 772px, 100vw"}]},"width":772,"height":360}},"publicURL":"/static/60615dd0a50be3f0619f28c8c9b06c4c/image.png"},"sources":null,"sources_link":null}}}]}},"pageContext":{"slug":"/tech/2023-07-31-Token을-어떻게-관리할-것인가/","previous":{"fields":{"slug":"/tech/2023-07-28-XSS와-CSRF/"},"frontmatter":{"tags":["보안"],"update":true,"title":"XSS와 CSRF"}},"next":{"fields":{"slug":"/tech/2023-08-20-Context-API-최적화/"},"frontmatter":{"tags":["React","상태 관리"],"update":true,"title":"Context API 최적화"}}}},"staticQueryHashes":[],"slicesMap":{}}