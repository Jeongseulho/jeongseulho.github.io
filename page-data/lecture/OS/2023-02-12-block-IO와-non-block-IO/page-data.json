{"componentChunkName":"component---src-templates-lecture-template-tsx","path":"/lecture/OS/2023-02-12-block-IO와-non-block-IO/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1 id=\"io의-종류\" style=\"position:relative;\"><a href=\"#io%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"io의 종류 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IO의 종류</h1>\n<ul>\n<li>network(socket)</li>\n<li>file</li>\n<li>pipe(process 간 통신)</li>\n<li>device</li>\n</ul>\n<h1 id=\"socket\" style=\"position:relative;\"><a href=\"#socket\" aria-label=\"socket permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>socket</h1>\n<ul>\n<li>네트워크 통신은 <code class=\"language-text\">socket</code>을 통해 데이터가 주고받아짐</li>\n<li>통신하고자 하는 두 프로세스는 각 소켓을 열고 이를통하여 통신</li>\n</ul>\n<p><img src=\"https://github.com/user-attachments/assets/050fa40f-a955-496d-a025-b00dc46f8c08\" alt=\"Image\"></p>\n<h1 id=\"스레드에서-blocking-io\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C-blocking-io\" aria-label=\"스레드에서 blocking io permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드에서 blocking IO</h1>\n<p><img src=\"https://github.com/user-attachments/assets/22a2b3fa-db98-4249-89f8-9004eaa1157b\" alt=\"Image\">\r\n스레드에서 blocking system call을 호출하면 해당 IO 작업이 완료될 때까지 스레드는 대기<br>\n커널은 작업이 완료되어야 결과를 리턴</p>\n<blockquote>\n<p>스레드는 IO가 발생하면 waiting 상태로 전환됨<br>\n즉, blocking이 되어도 CPU는 계속 일하고 있지만<br>\nIO 작업이 완료되기 전까지 waiting이므로 다른 스레드와의 CPU 사용 경쟁에서 불리함</p>\n</blockquote>\n<h1 id=\"소켓에서-blocking-io\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%BC%93%EC%97%90%EC%84%9C-blocking-io\" aria-label=\"소켓에서 blocking io permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소켓에서 blocking IO</h1>\n<ul>\n<li>소켓 A는 데이터를 받는 입장</li>\n<li>소켓 S는 데이터를 전송하는 입장</li>\n</ul>\n<p><img src=\"https://github.com/user-attachments/assets/5882296f-d707-49d3-8435-4b36a7fe9d49\" alt=\"Image\">\r\n<code class=\"language-text\">raed(socket A)</code>를 호출 시 <code class=\"language-text\">recv_buffer</code>가 비어져 있으면 데이터가 올때까지 대기 => blocking<br>\n<code class=\"language-text\">write(socket S)</code>를 호출 시 <code class=\"language-text\">send_buffer</code>가 가득 차있으면 자리가 생길때까지 대기 => blocking</p>\n<h1 id=\"스레드에서-non-blocking-io\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C-non-blocking-io\" aria-label=\"스레드에서 non blocking io permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드에서 non-blocking IO</h1>\n<p><img src=\"https://github.com/user-attachments/assets/18f4830a-d747-4499-8dd4-7d6bd8e21ae5\" alt=\"Image\">\r\nnon-blocking system call을 호출하면 커널은 IO 작업 완료 전 결과를 즉시 리턴<br>\n스레드는 다른 작업을 계속 진행할 수 있음</p>\n<blockquote>\n<p>non-blocking은 IO가 발생하여도 스레드는 waiting 상태로 전환되지 않음<br>\n스레드는 커널에 작업이 완료되었는지 주기적으로 확인하거나<br>\n완료되면 커널에게 알림을 받아 결과를 처리하는 2가지 방식 존재</p>\n</blockquote>\n<h1 id=\"소켓에서-non-blocking-io\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%BC%93%EC%97%90%EC%84%9C-non-blocking-io\" aria-label=\"소켓에서 non blocking io permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소켓에서 non-blocking IO</h1>\n<p><img src=\"https://github.com/user-attachments/assets/6e423402-5118-4c0a-a628-f2c9d4b8efe6\" alt=\"Image\">\r\n스레드의 non-blocking IO와 마찬가지로 <code class=\"language-text\">read</code>, <code class=\"language-text\">write</code> 호출 시 커널은 즉시 결과를 리턴</p>\n<h1 id=\"io-멀티플렉싱\" style=\"position:relative;\"><a href=\"#io-%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1\" aria-label=\"io 멀티플렉싱 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IO 멀티플렉싱</h1>\n<ul>\n<li>IO 작업들을 동시에 system call로 요청하고 완료된 작업들을 한번에 알려줌줌</li>\n</ul>\n<p><img src=\"https://github.com/user-attachments/assets/a169fc7c-72ea-41a6-815a-e4c25ab016c5\" alt=\"Image\">\r\n2개 소켓의 <code class=\"language-text\">non-blocking read</code>를 한번의 <code class=\"language-text\">system call</code>로 호출\r\n알려줄 때도 한번에 2개의 작업에 대해 완료 여부 및 결과를 알려줌</p>\n<blockquote>\n<p>위에서는 blocked 된 스레드로 그려졌지만<br>\n스레드가 run/blocked 될지는 상황, 구현에 따라 다름<br>\n즉, IO 멀티플렉싱은 스레드가 block, non-block과 관계없이 한번에 여러 요청을 커널에 전달, 결과를 받는 것이 핵심</p>\n</blockquote>\n<h2 id=\"io-멀티플렉싱의-종류\" style=\"position:relative;\"><a href=\"#io-%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"io 멀티플렉싱의 종류 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IO 멀티플렉싱의 종류</h2>\n<ul>\n<li>select</li>\n<li>poll</li>\n<li>epoll(Linux)</li>\n<li>kqueue(Mac OS)</li>\n<li>IOCP(Windows)</li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#io%EC%9D%98-%EC%A2%85%EB%A5%98\">IO의 종류</a></p>\n</li>\n<li>\n<p><a href=\"#socket\">socket</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C-blocking-io\">스레드에서 blocking IO</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%86%8C%EC%BC%93%EC%97%90%EC%84%9C-blocking-io\">소켓에서 blocking IO</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C-non-blocking-io\">스레드에서 non-blocking IO</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%86%8C%EC%BC%93%EC%97%90%EC%84%9C-non-blocking-io\">소켓에서 non-blocking IO</a></p>\n</li>\n<li>\n<p><a href=\"#io-%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1\">IO 멀티플렉싱</a></p>\n<ul>\n<li><a href=\"#io-%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1%EC%9D%98-%EC%A2%85%EB%A5%98\">IO 멀티플렉싱의 종류</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"block IO와 non-block IO","date":"2023년 02월 12일","tags":["CS"]}}}]}},"pageContext":{"slug":"/lecture/OS/2023-02-12-block-IO와-non-block-IO/","previous":{"fields":{"slug":"/lecture/OS/2023-02-11-스레드-풀/"},"frontmatter":{"categories":["OS"],"title":"스레드 풀","date":"2023-02-11 09:00:00 +0900","tags":["CS"]}},"next":{"fields":{"slug":"/lecture/OS/2023-02-13-비동기의-다양한-의미/"},"frontmatter":{"categories":["OS"],"title":"비동기의 다양한 의미","date":"2023-02-13 09:00:00 +0900","tags":["CS"]}}}},"staticQueryHashes":[],"slicesMap":{}}