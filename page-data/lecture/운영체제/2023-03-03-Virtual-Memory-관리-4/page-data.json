{"componentChunkName":"component---src-templates-lecture-template-tsx","path":"/lecture/운영체제/2023-03-03-Virtual-Memory-관리-4/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2 id=\"variable-allocation에서-전략\" style=\"position:relative;\"><a href=\"#variable-allocation%EC%97%90%EC%84%9C-%EC%A0%84%EB%9E%B5\" aria-label=\"variable allocation에서 전략 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📌variable allocation에서 전략</h2>\n<h3 id=\"working-set-algorithm\" style=\"position:relative;\"><a href=\"#working-set-algorithm\" aria-label=\"working set algorithm permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📖working set algorithm</h3>\n<ul>\n<li>working set : 최근 일정시간 동안 참조된 page들의 집합</li>\n<li>시간에 따라 변함</li>\n<li>W(t, delta) : time interval<code class=\"language-text\">[t - delta, t]</code> 동안 참조된 page들의 집합</li>\n<li>간격 delta를 window또는 windows size라고 한다\r\n<img src=\"https://velog.velcdn.com/images/wjdtmfgh/post/9094149a-e086-431f-8eab-567776c64b8c/image.png\" alt=\"\"></li>\n<li>locality를 기반으로 함</li>\n<li>working set을 메모리에 항상 유지</li>\n<li>windows size는 항상 고정, 해당 delta값이 성능을 결정짓는 중요 요소</li>\n</ul>\n<h3 id=\"working-set-transition\" style=\"position:relative;\"><a href=\"#working-set-transition\" aria-label=\"working set transition permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📖working set transition</h3>\n<ul>\n<li>loop1에서 다른 loop2로 갈때, 순간적으로 loop1의 WS page들과 loop2의 WS page들을 모두 사용하는 WS를 구성하게 되므로 WS크기가 잠깐 증가한다\r\n<img src=\"https://velog.velcdn.com/images/wjdtmfgh/post/b6decfe9-a92e-4a96-8c88-d6f5c2a5f4f3/image.png\" alt=\"\">\r\n<img src=\"https://velog.velcdn.com/images/wjdtmfgh/post/67849984-689d-4b72-97a4-1d8ace991089/image.png\" alt=\"\"></li>\n</ul>\n<h3 id=\"성능-평가\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5-%ED%8F%89%EA%B0%80\" aria-label=\"성능 평가 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📖성능 평가</h3>\n<ul>\n<li>page fault수</li>\n<li>평균 할당 받은 page frame수</li>\n</ul>\n<h3 id=\"️특징\" style=\"position:relative;\"><a href=\"#%EF%B8%8F%ED%8A%B9%EC%A7%95\" aria-label=\"️특징 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>❗️특징</h3>\n<ul>\n<li>적재되는 새로운 page가 없어도 메모리를 반납하는 page가 있을 수 있다</li>\n<li>적재되는 새로운 page가 있지만, 메모리를 반납하는 page가 없을 수 있다</li>\n<li>WS을 계속 업데이트, 갱신, 관리가 필요</li>\n</ul>\n<h3 id=\"page-fault-frequency-algorithm\" style=\"position:relative;\"><a href=\"#page-fault-frequency-algorithm\" aria-label=\"page fault frequency algorithm permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📖page fault frequency algorithm</h3>\n<ul>\n<li>residence set size(사실상 WS)를 page fault rate에 따라 결정\n<ul>\n<li>low page fault rate이면 procees에게 할당된 page frame수 감소</li>\n<li>high page fault rate이면 process에게 할당된 page frame수 증가</li>\n</ul>\n</li>\n<li>page fault가 발생시에만 resident set 갱신</li>\n<li>IFT = inter-fault-time(page fault사이의 간격)</li>\n</ul>\n<ol>\n<li>page fault 발생 시 IFT 계산 $$t_c - t_{c-1} = IFT$$\n<ul>\n<li>$$t_c : 현재 발생한 page-fault-time$$</li>\n<li>$$t_{c-1} : 직전에 발생한 page-fault-time$$</li>\n</ul>\n</li>\n<li>IFT > 기준 간격이면 $$(t_c - t_{c-1}]$$동안 참조된 page들만 resident set에 유지, 나머지는 메모리에서 내림</li>\n<li>IFT &#x3C;= 기준 간격이면 기존 page들 + 현재 참조된 page를 추가 적재</li>\n</ol>\n<ul>\n<li>메모리 상태변화가 page fault 발생시에만 일어나므로 low overhead</li>\n</ul>\n<h3 id=\"variable-min-algorithm\" style=\"position:relative;\"><a href=\"#variable-min-algorithm\" aria-label=\"variable min algorithm permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📖variable MIN algorithm</h3>\n<ul>\n<li>평균메모리 할당량과, page fault 발생 횟수 모두 고려</li>\n<li>page referebce string을 미리 알고 있어야함, 실현 불가능</li>\n<li>[t, t + delta]를 고려해서 교체할 page 선택</li>\n<li>page R이 t시간에 참조되면 (t, t + delta]사이에 다시 참조되는지 확인 후 참조되면 page 유지, 참조 안되면 내림</li>\n</ul>\n<h3 id=\"최적-성능-계산\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81-%EC%84%B1%EB%8A%A5-%EA%B3%84%EC%82%B0\" aria-label=\"최적 성능 계산 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📖최적 성능 계산</h3>\n<ul>\n<li>가장 최적의 delta값은 무엇인가?</li>\n<li>delta = R / U</li>\n<li>U : 한번 참조 시간 동안 page를 메모리에 유지하는 비용</li>\n<li>delta * U : 총 page 유지 비용</li>\n<li>R : page fault 발생 시 처리 비용</li>\n</ul>\n<ol>\n<li>R > delta * U 이면, page fault 처리비용 > page 유지 비용이면\r\ndelta를 늘려서 page fault처리를 줄이고 page유지를 위주로 한다</li>\n<li>R &#x3C; delta * U 이면, page fault 처리비용 &#x3C; page 유지 비용이면\r\ndelta를 줄여서 page 유지를 줄이고 page fault 처리를 위주로 한다</li>\n</ol>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#variable-allocation%EC%97%90%EC%84%9C-%EC%A0%84%EB%9E%B5\">📌variable allocation에서 전략</a></p>\n<ul>\n<li><a href=\"#working-set-algorithm\">📖working set algorithm</a></li>\n<li><a href=\"#working-set-transition\">📖working set transition</a></li>\n<li><a href=\"#%EC%84%B1%EB%8A%A5-%ED%8F%89%EA%B0%80\">📖성능 평가</a></li>\n<li><a href=\"#%EF%B8%8F%ED%8A%B9%EC%A7%95\">❗️특징</a></li>\n<li><a href=\"#page-fault-frequency-algorithm\">📖page fault frequency algorithm</a></li>\n<li><a href=\"#variable-min-algorithm\">📖variable MIN algorithm</a></li>\n<li><a href=\"#%EC%B5%9C%EC%A0%81-%EC%84%B1%EB%8A%A5-%EA%B3%84%EC%82%B0\">📖최적 성능 계산</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Virtual Memory 관리 4","date":"2023년 03월 02일","tags":["CS"]}}}]}},"pageContext":{"slug":"/lecture/운영체제/2023-03-03-Virtual-Memory-관리-4/","previous":{"fields":{"slug":"/lecture/운영체제/2023-03-02-Virtual-Memory-관리-3/"},"frontmatter":{"categories":["운영체제"],"title":"Virtual Memory 관리 3","date":"2023-03-02 01:00:00 +0900","tags":["CS"]}},"next":{"fields":{"slug":"/lecture/운영체제/2023-03-06-Virtual-Memory-관리-5/"},"frontmatter":{"categories":["운영체제"],"title":"Virtual Memory 관리 5","date":"2023-03-06 01:00:00 +0900","tags":["CS"]}}}},"staticQueryHashes":[],"slicesMap":{}}