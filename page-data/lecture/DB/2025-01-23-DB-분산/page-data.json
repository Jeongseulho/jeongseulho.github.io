{"componentChunkName":"component---src-templates-lecture-template-tsx","path":"/lecture/DB/2025-01-23-DB-분산/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1 id=\"partitioning\" style=\"position:relative;\"><a href=\"#partitioning\" aria-label=\"partitioning permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>partitioning</h1>\n<ul>\n<li>테이블을 더 작은 테이블들로 나누는 것</li>\n</ul>\n<h2 id=\"vertical-partitioning\" style=\"position:relative;\"><a href=\"#vertical-partitioning\" aria-label=\"vertical partitioning permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>vertical partitioning</h2>\n<ul>\n<li>컬럼을 기준으로 테이블을 나누는 것</li>\n<li>정규화 또한 vertical partitioning의 일종</li>\n</ul>\n<h2 id=\"vertical-partitioning이-필요한-상황\" style=\"position:relative;\"><a href=\"#vertical-partitioning%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%83%81%ED%99%A9\" aria-label=\"vertical partitioning이 필요한 상황 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>vertical partitioning이 필요한 상황</h2>\n<p><img src=\"https://github.com/user-attachments/assets/95f703c3-0357-4869-a0c0-1651be9c573c\" alt=\"Image\">\r\n<code class=\"language-text\">article</code> 테이블이 있고 <code class=\"language-text\">content</code> 컬럼이 크기가 매우 크다고 가정,<br>\n다음과 같이 <code class=\"language-text\">content</code> 컬럼을 제외한 쿼리를 날리면</p>\n<div\n              class=\"gatsby-code-button-container\"\n              data-toaster-id=\"31497846629023460000\"\n              data-toaster-class=\"gatsby-code-button-toaster\"\n              data-toaster-text-class=\"gatsby-code-button-toaster-text\"\n              data-toaster-text=\"📋  코드를 복사했습니다.\"\n              data-toaster-duration=\"3000\"\n              onClick=\"copyToClipboard(`SELECT id, title FROM article WHERE id = 1;`, `31497846629023460000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-tooltip=\"\"\n              >\n                copy<svg stroke=\"currentColor\" fill=\"none\" stroke-width=\"2\" viewBox=\"0 0 24 24\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"h-4 w-4\" height=\"1em\" width=\"1em\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect></svg>\n              </div>\n            </div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span> title <span class=\"token keyword\">FROM</span> article <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>HDD에서 RAM으로 WHERE에 해당하는 로우를 가져오고, 그 이후 특정 컬럼을 추출하는 과정을 RAM에서 처리<br>\n즉, <code class=\"language-text\">content</code>는 사용하지 않지만 HDD에서 RAM으로 가져와지게 됨 => 비효율적인 <code class=\"language-text\">I/O</code> 발생</p>\n<p><img src=\"https://github.com/user-attachments/assets/122defdf-2213-4d41-bcc2-22fe513e76a6\" alt=\"Image\">\r\n위와 같이 <code class=\"language-text\">vertical partitioning</code>을 하면 더 효율적</p>\n<blockquote>\n<p>위는 성능 향상 목적으로한 분할<br>\n이외에도 민감한 정보를 분리하기 위한 보안 목적<br>\n자주 사용되는 컬럼을 분리하기도 한다.</p>\n</blockquote>\n<h2 id=\"horizontal-partitioning\" style=\"position:relative;\"><a href=\"#horizontal-partitioning\" aria-label=\"horizontal partitioning permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>horizontal partitioning</h2>\n<ul>\n<li>로우를 기준으로 테이블을 나누는 것</li>\n</ul>\n<h2 id=\"horizontal-partitioning이-필요한-상황\" style=\"position:relative;\"><a href=\"#horizontal-partitioning%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%83%81%ED%99%A9\" aria-label=\"horizontal partitioning이 필요한 상황 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>horizontal partitioning이 필요한 상황</h2>\n<p><code class=\"language-text\">hash based</code>를 기준으로한 <code class=\"language-text\">horizontal partitioning</code>이며 다른 방법도 있음</p>\n<p><img src=\"https://github.com/user-attachments/assets/ae76f29d-2912-4c96-90c6-6f64f53e8421\" alt=\"Image\">\r\n어떤 유저가 어떤 유튜브 채널을 구독하는지 확인하는 테이블이 있고, 이 테이블의 로우가 매우 많다고 가정<br>\n로우가 많아지면 인덱스도 커지며 <code class=\"language-text\">read/write</code> 성능이 저하</p>\n<p><img src=\"https://github.com/user-attachments/assets/72973d6f-8341-408a-9e58-8c22dd05ba52\" alt=\"Image\">\r\n다음과 같이 <code class=\"language-text\">user_id</code>를 <code class=\"language-text\">hash</code> 함수로 해싱하여 이를 기준으로 테이블을 분리<br>\n이때 분리의 기준이되는 <code class=\"language-text\">user_id</code>를 <code class=\"language-text\">partition key</code>라고 함</p>\n<p>위 그림에서 <code class=\"language-text\">user_id</code>가 <code class=\"language-text\">yeah</code>의 구독한 채널들은 <code class=\"language-text\">hash</code> 함수로 해싱하여 해당 하는 테이블로 접근하면<br>\n기존 테이블에 비하여 row가 1/2로 줄어듦, 즉 성능이 향상됨</p>\n<blockquote>\n<p><code class=\"language-text\">channel_id</code>가 <code class=\"language-text\">1</code>인 채널을 구독한 유저들은 2개의 테이블에 나누어져 성능 향상에 이점이 없음<br>\n즉, <code class=\"language-text\">partition key</code>를 잘 선택하는 것이 중요<br>\n또한, 각 파티션의 로우가 균일하게 분포되어야 하므로 어떤 <code class=\"language-text\">hash</code> 함수를 사용하는지도 중요</p>\n</blockquote>\n<h1 id=\"sharding\" style=\"position:relative;\"><a href=\"#sharding\" aria-label=\"sharding permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sharding</h1>\n<ul>\n<li><code class=\"language-text\">horizontal partitioning</code>으로 나누어진 테이블을 여러 대의 서버에 분산하는 것</li>\n<li>부하 분산으로 병목 현상 방지</li>\n<li>여기서 각 파티션을 <code class=\"language-text\">shard</code>라고 함</li>\n</ul>\n<h1 id=\"replication\" style=\"position:relative;\"><a href=\"#replication\" aria-label=\"replication permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>replication</h1>\n<ul>\n<li>DB를 복제하여 여러 대의 DB를 사용하는 것</li>\n<li>주 DB(<code class=\"language-text\">leader</code>)과 복제된 DB(<code class=\"language-text\">replica</code>)이 있고 주 DB를 사용하며 복제된 DB를 <code class=\"language-text\">sync</code> 함</li>\n<li><code class=\"language-text\">leader</code>에 문제가 생기면 <code class=\"language-text\">replica</code>를 사용 가능 => 고가용성(<code class=\"language-text\">high availability</code>)</li>\n<li><code class=\"language-text\">read</code> 연산의 경우 부하 분산이 가능</li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#partitioning\">partitioning</a></p>\n<ul>\n<li><a href=\"#vertical-partitioning\">vertical partitioning</a></li>\n<li><a href=\"#vertical-partitioning%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%83%81%ED%99%A9\">vertical partitioning이 필요한 상황</a></li>\n<li><a href=\"#horizontal-partitioning\">horizontal partitioning</a></li>\n<li><a href=\"#horizontal-partitioning%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%83%81%ED%99%A9\">horizontal partitioning이 필요한 상황</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#sharding\">sharding</a></p>\n</li>\n<li>\n<p><a href=\"#replication\">replication</a></p>\n</li>\n</ul>","frontmatter":{"title":"DB 분산","date":"2025년 01월 23일","tags":["CS"]}}}]}},"pageContext":{"slug":"/lecture/DB/2025-01-23-DB-분산/","previous":{"fields":{"slug":"/lecture/DB/2025-01-22-B-tree/"},"frontmatter":{"categories":["DB"],"title":"B tree","date":"2025-01-22 18:00:00 +0900","tags":["CS"]}},"next":{"fields":{"slug":"/lecture/DB/2025-01-24-DBCP/"},"frontmatter":{"categories":["DB"],"title":"DBCP","date":"2025-01-24 18:00:00 +0900","tags":["CS"]}}}},"staticQueryHashes":[],"slicesMap":{}}