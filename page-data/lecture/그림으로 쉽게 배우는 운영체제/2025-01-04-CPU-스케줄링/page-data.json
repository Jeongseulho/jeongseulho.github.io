{"componentChunkName":"component---src-templates-lecture-template-tsx","path":"/lecture/그림으로 쉽게 배우는 운영체제/2025-01-04-CPU-스케줄링/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1 id=\"스케줄링-목표\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EB%AA%A9%ED%91%9C\" aria-label=\"스케줄링 목표 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케줄링 목표</h1>\n<ol>\n<li>리소스 사용률 최대화</li>\n<li>오버헤드 최소화</li>\n<li>프로세스에게 자원 할당 공평화</li>\n<li>처리량 최대화</li>\n<li>요청 - 작업시작 간의 대기시간 최소화</li>\n<li>응답시간 최소화</li>\n</ol>\n<h1 id=\"스케줄링-종류\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%A2%85%EB%A5%98\" aria-label=\"스케줄링 종류 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케줄링 종류</h1>\n<ul>\n<li>burst time : 프로세스가 CPU를 사용하는 시간</li>\n<li>time slice : 프로세스에게 부여된 CPU 할당 시간</li>\n<li>FIFO(First In First Out)\n<ul>\n<li>먼저 온 프로세스를 먼저 처리</li>\n<li>평균 대기시간이 길어질 수 있음(burst time이 큰 프로세스가 먼저 점유해버리면 뒤에 프로세스는 오래 기다림)</li>\n</ul>\n</li>\n<li>SJF(Shortest Job First)\n<ul>\n<li>짧은 burst time을 가진 프로세스를 먼저 처리</li>\n<li>평균 대기시간이 짧음</li>\n<li>starvation 문제(burst time이 큰 프로세스는 계속해서 뒤로 밀릴 수 있음)</li>\n<li>burst time은 예측하기 어려운 경우가 다수</li>\n</ul>\n</li>\n<li>RR(Round Robin)\n<ul>\n<li>시분할 시스템</li>\n<li>각 프로세스는 동일한 크기의 CPU 시간을 할당받음</li>\n<li>할당받은 시간이 지나면 다음 프로세스로 넘어감</li>\n<li>시간이 너무 작으면 오버헤드(컨텍스트 스위칭)가 발생, 너무 크면 FIFO와 같은 효과</li>\n</ul>\n</li>\n<li>MLFQ(Multi Level Feedback Queue)</li>\n</ul>\n<p><img src=\"https://github.com/user-attachments/assets/f519b948-1f71-4567-90ce-70bbbaafb10e\" alt=\"image\"></p>\n<ul>\n<li>가장 높은 우선순위 큐에 할당 이후 프로세스 종류에따라 아래 우선순위 큐로 이동</li>\n<li>우선순위가 높은 큐\n<ul>\n<li>time slice가 짧게</li>\n<li>반응성을 높이기 위한 IO 작업이 주로 배치</li>\n</ul>\n</li>\n<li>우선순위가 낮은 큐\n<ul>\n<li>time slice가 길게</li>\n<li>CPU 사용량이 많은 CPU 작업이 주로 배치</li>\n</ul>\n</li>\n<li>아래 큐로 이동하는 과정\n<ol>\n<li>짧은 time slice에서 계속해서 작업 완료전에 끊김</li>\n<li>CPU 중심 프로세스임을 확인</li>\n<li>time slice를 늘려주는 아래 큐로 이동</li>\n</ol>\n<ul>\n<li>IO 중심 프로세스는 작업 완료전에 IO 인터럽트로 끊김 => 내려가지 않고 높은 우선순위의 짧은 time slice에서 높은 반응성 가짐</li>\n</ul>\n</li>\n</ul>","tableOfContents":"<ul>\n<li><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EB%AA%A9%ED%91%9C\">스케줄링 목표</a></li>\n<li><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%A2%85%EB%A5%98\">스케줄링 종류</a></li>\n</ul>","frontmatter":{"title":"CPU 스케줄링","date":"2025년 01월 03일","tags":["CS"]}}}]}},"pageContext":{"slug":"/lecture/그림으로 쉽게 배우는 운영체제/2025-01-04-CPU-스케줄링/","previous":{"fields":{"slug":"/lecture/그림으로 쉽게 배우는 운영체제/2024-12-23-운영체제-개요/"},"frontmatter":{"categories":["그림으로 쉽게 배우는 운영체제"],"title":"운영체제 개요","date":"2024-12-23 01:00:00 +0900","tags":["CS"]}},"next":{"fields":{"slug":"/lecture/그림으로 쉽게 배우는 운영체제/2025-01-04-프로세스와-쓰레드 copy/"},"frontmatter":{"categories":["그림으로 쉽게 배우는 운영체제"],"title":"프로세스와 쓰레드","date":"2025-01-04 01:00:00 +1000","tags":["CS"]}}}},"staticQueryHashes":[],"slicesMap":{}}